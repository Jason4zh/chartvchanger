<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhigrosæŒ‰é”®è½¬æ¢å™¨</title>
    <link rel="stylesheet" href="common.css">
</head>
<body>
    <div class="container">
    <header>
            <h1>PhigrosæŒ‰é”®è½¬æ¢å™¨</h1>
        </header>
        
        <div class="main-content">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ğŸ“</div>
                <p>ä¸Šä¼ Phigrosè°±é¢ZIPæ–‡ä»¶</p>
                <input type="file" id="fileInput" accept=".zip">
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>å¤„ç†ä¸­...</p>
            </div>
            
            <div class="controls-section" id="controlsSection">
                <div class="file-info" id="fileInfo">
                    <div class="info-item">
                        <span>æ–‡ä»¶:</span>
                        <span id="fileName">-</span>
                    </div>
                    <div class="info-item">
                        <span>æŒ‰é”®æ•°:</span>
                        <span id="noteCount">-</span>
                    </div>
                    <div class="info-item">
                        <span>formatVersion:</span>
                        <span id="formatVersion">-</span>
                    </div>
                    <div class="info-item">
                        <span>åˆ¤å®šçº¿æ•°:</span>
                        <span id="judgeLineCount">-</span>
                    </div>
                </div>
                
                <div class="conversion-controls">
                    <div class="conversion-options">
                        <button class="conversion-btn" data-type="tap">Tap</button>
                        <button class="conversion-btn" data-type="drag">Drag</button>
                        <button class="conversion-btn" data-type="hold">Hold</button>
                        <button class="conversion-btn" data-type="flick">Flick</button>
                    </div>
                    
                    <div class="hold-controls" id="holdControls">
                        <div class="hold-option">
                            <input type="checkbox" id="includeHold" checked>
                            <label for="includeHold">åŒ…å«HoldæŒ‰é”®</label>
                        </div>
                        <div class="hold-length" id="holdLengthControl">
                            <label>æœ€å°é•¿åº¦:</label>
                            <input type="number" id="holdLength" value="200" min="50" max="1000">
                            <span>ms</span>
                        </div>
                    </div>
                </div>
                
                <button class="download-btn" id="downloadBtn" disabled>
                    ä¸‹è½½è½¬æ¢åçš„ZIPæ–‡ä»¶
                </button>
                
                <div class="status" id="status"></div>
                
                <!-- æ–°å¢ï¼šè°ƒè¯•ä¿¡æ¯åŒºåŸŸ -->
                <div class="debug-info" id="debugInfo" style="display: none; margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 4px; font-family: monospace; font-size: 12px;">
                    <h4 style="margin-bottom: 10px;">è°ƒè¯•ä¿¡æ¯</h4>
                    <div id="debugContent"></div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>æœ¬å·¥å…·å®Œå…¨åœ¨æµè§ˆå™¨ä¸­è¿è¡Œï¼Œä¸ä¼šä¸Šä¼ æ–‡ä»¶åˆ°æœåŠ¡å™¨</p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        let originalZip = null
        let jsonFileName = null
        let chartData = null
        let selectedType = 'tap'
        let originalFileName = ''
        
        const uploadArea = document.getElementById('uploadArea')
        const fileInput = document.getElementById('fileInput')
        const loading = document.getElementById('loading')
        const controlsSection = document.getElementById('controlsSection')
        const downloadBtn = document.getElementById('downloadBtn')
        const status = document.getElementById('status')
        const holdControls = document.getElementById('holdControls')
        const holdLengthControl = document.getElementById('holdLengthControl')
        const includeHoldCheck = document.getElementById('includeHold')
        const holdLengthInput = document.getElementById('holdLength')
        
        const fileNameSpan = document.getElementById('fileName')
        const noteCountSpan = document.getElementById('noteCount')
        const formatVersionSpan = document.getElementById('formatVersion')
        const judgeLineCountSpan = document.getElementById('judgeLineCount')
        const debugInfo = document.getElementById('debugInfo')
        const debugContent = document.getElementById('debugContent')
        
        function init() {
            uploadArea.addEventListener('click', () => fileInput.click())
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault()
                uploadArea.style.borderColor = '#3498db'
            })
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.style.borderColor = '#bdc3c7'
            })
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault()
                uploadArea.style.borderColor = '#bdc3c7'
                if (e.dataTransfer.files.length) {
                    handleFileUpload(e.dataTransfer.files[0])
                }
            })
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length) {
                    handleFileUpload(e.target.files[0])
                }
            })
            
            document.querySelectorAll('.conversion-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.conversion-btn').forEach(b => b.classList.remove('selected'))
                    this.classList.add('selected')
                    selectedType = this.dataset.type
                    
                    if (selectedType === 'hold') {
                        holdLengthControl.style.display = 'flex'
                        includeHoldCheck.style.display = 'none'
                    } else {
                        holdLengthControl.style.display = 'none'
                        includeHoldCheck.style.display = 'flex'
                    }
                })
            })
            
            document.querySelector('.conversion-btn[data-type="tap"]').click()
            
            downloadBtn.addEventListener('click', downloadConvertedZip)
        }
        
        function getTypeValue(type) {
            const values = { tap: 1, drag: 2, hold: 3, flick: 4 }
            return values[type] || 1
        }
        
        async function handleFileUpload(file) {
            if (!file.name.toLowerCase().endsWith('.zip')) {
                showStatus('è¯·ä¸Šä¼ ZIPæ–‡ä»¶', 'error')
                return
            }
            
            loading.classList.add('show')
            
            try {
                const arrayBuffer = await file.arrayBuffer()
                originalZip = await JSZip.loadAsync(arrayBuffer)
                
                originalFileName = file.name.replace(/\.zip$/i, '')
                
                const jsonFiles = []
                originalZip.forEach((relativePath, fileEntry) => {
                    if (!fileEntry.dir && relativePath.toLowerCase().endsWith('.json')) {
                        jsonFiles.push(relativePath)
                    }
                })
                
                if (jsonFiles.length === 0) {
                    throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°JSONæ–‡ä»¶')
                }
                
                jsonFileName = jsonFiles[0]
                
                const jsonFile = originalZip.file(jsonFileName)
                if (!jsonFile) {
                    throw new Error('æ— æ³•è¯»å–JSONæ–‡ä»¶')
                }
                
                const jsonText = await jsonFile.async('text')
                chartData = JSON.parse(jsonText)
                
                // æ˜¾ç¤ºè¯¦ç»†çš„è°±é¢ä¿¡æ¯
                const noteCount = countNotes(chartData)
                const judgeLineCount = chartData.judgeLineList ? chartData.judgeLineList.length : 0
                
                fileNameSpan.textContent = file.name
                noteCountSpan.textContent = noteCount
                formatVersionSpan.textContent = chartData.formatVersion || 'æœªçŸ¥'
                judgeLineCountSpan.textContent = judgeLineCount
                
                // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
                showDebugInfo('åŸå§‹è°±é¢åŠ è½½æˆåŠŸ', {
                    'æ–‡ä»¶å': file.name,
                    'formatVersion': chartData.formatVersion,
                    'åˆ¤å®šçº¿æ•°é‡': judgeLineCount,
                    'æ€»æŒ‰é”®æ•°': noteCount,
                    'JSONæ–‡ä»¶': jsonFileName
                })
                
                // åˆ†æè°±é¢ç»“æ„
                analyzeChartStructure(chartData)
                
                controlsSection.classList.add('show')
                debugInfo.style.display = 'block'
                downloadBtn.disabled = false
                
                showStatus('æˆåŠŸåŠ è½½è°±é¢', 'success')
                
            } catch (error) {
                showStatus('å¤„ç†å¤±è´¥: ' + error.message, 'error')
                showDebugInfo('åŠ è½½å¤±è´¥', { 'é”™è¯¯': error.message })
            } finally {
                loading.classList.remove('show')
            }
        }
        
        function countNotes(chartData) {
            let count = 0
            if (chartData.judgeLineList) {
                chartData.judgeLineList.forEach((line, index) => {
                    // æ£€æŸ¥å¤šä¸ªå¯èƒ½çš„notesä½ç½®
                    const notes = line.notesAbove || line.notesBelow || line.notes
                    if (notes && Array.isArray(notes)) {
                        count += notes.length
                    }
                })
            }
            return count
        }
        
        function analyzeChartStructure(chartData) {
            const structureInfo = []
            
            if (!chartData.judgeLineList || !Array.isArray(chartData.judgeLineList)) {
                structureInfo.push('âŒ æœªæ‰¾åˆ°judgeLineListæˆ–ä¸æ˜¯æ•°ç»„')
                return
            }
            
            chartData.judgeLineList.forEach((line, lineIndex) => {
                structureInfo.push(`åˆ¤å®šçº¿ ${lineIndex + 1}:`)
                
                // æ£€æŸ¥å„ç§å¯èƒ½çš„noteså­—æ®µ
                const possibleNoteFields = ['notes', 'notesAbove', 'notesBelow', 'note', 'Note', 'Notes']
                let foundNotes = false
                
                for (const field of possibleNoteFields) {
                    if (line[field] && Array.isArray(line[field])) {
                        structureInfo.push(`  âœ“ æ‰¾åˆ° ${field}: ${line[field].length} ä¸ªæŒ‰é”®`)
                        foundNotes = true
                        
                        // æ˜¾ç¤ºå‰å‡ ä¸ªæŒ‰é”®çš„ç±»å‹
                        const sampleNotes = line[field].slice(0, 3)
                        sampleNotes.forEach((note, noteIndex) => {
                            structureInfo.push(`     æŒ‰é”® ${noteIndex + 1}: type=${note.type}, time=${note.time}`)
                        })
                        if (line[field].length > 3) {
                            structureInfo.push(`     ... è¿˜æœ‰ ${line[field].length - 3} ä¸ªæŒ‰é”®`)
                        }
                    }
                }
                
                if (!foundNotes) {
                    structureInfo.push(`  âŒ æœªæ‰¾åˆ°notesæ•°ç»„`)
                    // æ˜¾ç¤ºè¯¥å¯¹è±¡çš„æ‰€æœ‰é”®
                    structureInfo.push(`     å¯ç”¨å­—æ®µ: ${Object.keys(line).join(', ')}`)
                }
            })
            
            showDebugInfo('è°±é¢ç»“æ„åˆ†æ', structureInfo)
        }
        
        function convertChartData() {
    if (!chartData) return null

    const convertedData = JSON.parse(JSON.stringify(chartData))
    const targetTypeValue = getTypeValue(selectedType)
    const includeHold = includeHoldCheck.checked
    const holdMinLength = parseInt(holdLengthInput.value) || 200

    let totalConverted = 0
    let totalSkipped = 0
    const conversionLog = []

    if (!convertedData.judgeLineList || !Array.isArray(convertedData.judgeLineList)) {
        conversionLog.push('âŒ é”™è¯¯: æ²¡æœ‰æ‰¾åˆ°judgeLineList')
        showDebugInfo('è½¬æ¢é”™è¯¯', conversionLog)
        return convertedData
    }

    convertedData.judgeLineList.forEach((judgeLine, lineIndex) => {
        conversionLog.push(`å¤„ç†åˆ¤å®šçº¿ ${lineIndex + 1}:`)

        const noteFields = ['notes', 'notesAbove', 'notesBelow']
        let notesFound = false

        for (const field of noteFields) {
            if (judgeLine[field] && Array.isArray(judgeLine[field])) {
                notesFound = true
                const notes = judgeLine[field]
                conversionLog.push(`  åœ¨å­—æ®µ"${field}"ä¸­æ‰¾åˆ° ${notes.length} ä¸ªæŒ‰é”®`)

                let lineConverted = 0
                let lineSkipped = 0

                notes.forEach((note, noteIndex) => {
                    const originalType = note.type

                    // å¦‚æœå½“å‰æ˜¯ Hold ä¸”æœªå‹¾é€‰â€œåŒ…å« Holdâ€ï¼Œåˆ™è·³è¿‡
                    if (originalType === 3 && !includeHold) {
                        lineSkipped++
                        totalSkipped++
                        return
                    }

                    // å¦‚æœå½“å‰ç±»å‹å·²ç»æ˜¯ç›®æ ‡ç±»å‹ï¼Œè·³è¿‡
                    if (originalType === targetTypeValue) {
                        return
                    }

                    // æ‰§è¡Œè½¬æ¢
                    lineConverted++
                    totalConverted++

                    // è®¾ç½®æˆ–åˆ é™¤ holdTime
                    if (selectedType === 'hold') {
                        note.holdTime = (note.time || 0) + holdMinLength
                    } else {
                        if (note.hasOwnProperty('holdTime')) {
                            delete note.holdTime
                        }
                    }

                    // ä¿®æ”¹ç±»å‹
                    note.type = targetTypeValue

                    // è®°å½•å‰å‡ ä¸ªæŒ‰é”®çš„è½¬æ¢è¯¦æƒ…
                    if (noteIndex < 3) {
                        const typeNames = { 1: 'Tap', 2: 'Drag', 3: 'Hold', 4: 'Flick' }
                        const originalName = typeNames[originalType] || `æœªçŸ¥(${originalType})`
                        const targetName = typeNames[targetTypeValue] || `æœªçŸ¥(${targetTypeValue})`
                        conversionLog.push(`    æŒ‰é”® ${noteIndex + 1}: ${originalName} -> ${targetName}, time=${note.time}`)
                    }
                })

                conversionLog.push(`    è½¬æ¢ç»“æœ: è½¬æ¢äº†${lineConverted}ä¸ª, è·³è¿‡äº†${lineSkipped}ä¸ª`)
            }
        }

        if (!notesFound) {
            conversionLog.push(`  âš ï¸ æœªæ‰¾åˆ°notesæ•°ç»„`)
        }
    })

    conversionLog.push(`æ€»è®¡: è½¬æ¢äº†${totalConverted}ä¸ªæŒ‰é”®, è·³è¿‡äº†${totalSkipped}ä¸ªHold`)

    if (convertedData.numOfNotes !== undefined) {
        const newTotal = totalConverted + totalSkipped
        if (newTotal > 0) {
            convertedData.numOfNotes = newTotal
            conversionLog.push(`æ›´æ–°äº†numOfNoteså­—æ®µ: ${newTotal}`)
        }
    }

    if (chartData.formatVersion) {
        convertedData.formatVersion = chartData.formatVersion
        conversionLog.push(`ä¿æŒformatVersion: ${chartData.formatVersion}`)
    }

    showDebugInfo('è½¬æ¢è¿‡ç¨‹è¯¦æƒ…', conversionLog)
    return convertedData
}

        
        async function downloadConvertedZip() {
            if (!originalZip || !chartData) {
                showStatus('è¯·å…ˆä¸Šä¼ ZIPæ–‡ä»¶', 'error')
                return
            }
            
            downloadBtn.textContent = 'å¤„ç†ä¸­...'
            downloadBtn.disabled = true
            
            try {
                const convertedData = convertChartData()
                if (!convertedData) {
                    throw new Error('è½¬æ¢å¤±è´¥')
                }
                
                // éªŒè¯è½¬æ¢åçš„æ•°æ®
                const validationLog = ['éªŒè¯è½¬æ¢åçš„æ•°æ®:']
                const finalNoteCount = countNotes(convertedData)
                validationLog.push(`æŒ‰é”®æ€»æ•°: ${finalNoteCount}`)
                
                // æ£€æŸ¥å‡ ä¸ªç¤ºä¾‹æŒ‰é”®
                if (convertedData.judgeLineList && convertedData.judgeLineList[0]) {
                    const noteFields = ['notes', 'notesAbove', 'notesBelow']
                    for (const field of noteFields) {
                        if (convertedData.judgeLineList[0][field] && 
                            Array.isArray(convertedData.judgeLineList[0][field]) &&
                            convertedData.judgeLineList[0][field].length > 0) {
                            
                            const sample = convertedData.judgeLineList[0][field][0]
                            validationLog.push(`ç¤ºä¾‹æŒ‰é”®: type=${sample.type}, time=${sample.time}`)
                            
                            // æ˜¾ç¤ºå‰3ä¸ªæŒ‰é”®çš„ç±»å‹
                            convertedData.judgeLineList[0][field].slice(0, 3).forEach((note, i) => {
                                validationLog.push(`  æŒ‰é”®${i+1}: type=${note.type}${note.holdTime ? `, holdTime=${note.holdTime}` : ''}`)
                            })
                            break
                        }
                    }
                }
                
                showDebugInfo('è½¬æ¢éªŒè¯', validationLog)
                
                const modifiedZip = new JSZip()
                
                const promises = []
                originalZip.forEach((relativePath, file) => {
                    if (!file.dir) {
                        promises.push(
                            file.async('uint8array').then(content => {
                                if (relativePath === jsonFileName) {
                                    // ä½¿ç”¨ç´§å‡‘çš„JSONæ ¼å¼ï¼Œé¿å…ä¸å¿…è¦ç©ºæ ¼
                                    modifiedZip.file(relativePath, JSON.stringify(convertedData))
                                } else {
                                    modifiedZip.file(relativePath, content)
                                }
                            })
                        )
                    }
                })
                
                await Promise.all(promises)
                
                const zipBlob = await modifiedZip.generateAsync({
                    type: 'blob',
                    compression: "DEFLATE",
                    compressionOptions: {
                        level: 9
                    }
                })
                
                const url = URL.createObjectURL(zipBlob)
                const a = document.createElement('a')
                a.href = url
                a.download = `${originalFileName}_${selectedType}.zip`
                document.body.appendChild(a)
                a.click()
                document.body.removeChild(a)
                URL.revokeObjectURL(url)
                
                showStatus(`ä¸‹è½½æˆåŠŸï¼è½¬æ¢äº†${finalNoteCount}ä¸ªæŒ‰é”®`, 'success')
                
            } catch (error) {
                showStatus('ä¸‹è½½å¤±è´¥: ' + error.message, 'error')
                showDebugInfo('ä¸‹è½½é”™è¯¯', { 'é”™è¯¯': error.message })
            } finally {
                downloadBtn.textContent = 'ä¸‹è½½è½¬æ¢åçš„ZIPæ–‡ä»¶'
                downloadBtn.disabled = false
            }
        }
        
        function showDebugInfo(title, content) {
            debugContent.innerHTML = `<strong>${title}:</strong><br>`
            
            if (Array.isArray(content)) {
                content.forEach(line => {
                    debugContent.innerHTML += line + '<br>'
                })
            } else if (typeof content === 'object') {
                for (const [key, value] of Object.entries(content)) {
                    debugContent.innerHTML += `${key}: ${value}<br>`
                }
            } else {
                debugContent.innerHTML += content
            }
        }
        
        function showStatus(message, type = 'success') {
            status.textContent = message
            status.className = `status show ${type}`
            
            setTimeout(() => {
                status.classList.remove('show')
            }, 5000)
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            init()
        })
    </script>
</body>
</html>